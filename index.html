<!DOCTYPE><html><head><title>Test</title></head><body><script>

// initialize crossword puzzle
var CW = {
	size: 9,
	blank: ".", // standard char for blank fields
	black: "#", // standard char for black fields
	components: [],
	output: []
}
// add a word and its properties, as object, to the crossword puzzle
CW.add = function(i_word, i_definition, i_across, i_row, i_column, i_position) {
	this.components.push({word: i_word, definition: i_definition, across: i_across, row: i_row, column: i_column, position: i_position});
}
// generate output
CW.layout = function() {
	// create WC puzzle filled with NxN black squares
	for(var i = 0, result = [], temp = []; i < this.size; i++, temp = []) {
		for(var j = 0; j < this.size; j++) {
			temp.push([this.black]);
		}
		result.push(temp);
	}
	var l_components = this.components.length;
	// i cycles every word and its attributes
	for(i = 0; i < l_components; i++) {
		// new var to access quickly
		var currentword = this.components[i];
		// add word position in the layout
		result[currentword["row"]][currentword["column"]][0] = currentword["position"];
		// add as many points as word length, starting from 1 since we already filled 1 square with word position 
		for(j = 1; j < currentword["word"].length; j++) {
			// work horizontally, check if current square is black
			if((currentword["across"] == 0)&&(result[currentword["row"]][currentword["column"] + j] == this.black)) {
				result[currentword["row"]][currentword["column"] + j] = [this.blank];
			}
			// work vertically
			else if((currentword["across"] == 1)&&(result[currentword["row"] + j][currentword["column"]] == this.black)) {				
				// replace only if current square is a black square
			 		result[currentword["row"] + j][currentword["column"]] = [this.blank];
			}
		}
	}
	// merge single blocks into rows
	for(i = 0; i < result.length; i++) {
		result[i] = [].concat.apply([], result[i]);
	}
	// pass result to the element
	this.output = result;
	for(i = 0; i < this.output.length; i++) {
		for(j = 0; j < this.output[i].length; j++) {
			document.write(this.output[i][j]);
		}
		document.write("<br>");
	}
}

CW.add("Den", "Family room", 1, 0, 0, 1);
CW.add("Drink", "Milk or orange juice", 0, 0, 0, 1);
CW.add("India", "South Asian country", 1, 0, 2, 2);
CW.add("Knot", "Massage target", 1, 0, 4, 3);
CW.add("Cut", "Slice", 1, 0, 6, 4);
CW.add("Bathe", "Scrub in the tub", 1, 0, 8, 5);
CW.add("Cob", "Corn on the ___", 0, 0, 6, 4);
CW.add("Nod", "Affirmative head movement", 0, 2, 0, 6);
CW.add("Octet", "Quartet doubled", 0, 2, 4, 7);
CW.add("Crane", "Machine for lifting heavy objects", 1, 4, 0, 8);
CW.add("Chat", "Chew the fat", 0, 4, 0, 8);
CW.add("Shoe", "Loafer or sneaker", 0, 4, 5, 9);
CW.add("Herds", "Elephant groups", 1, 4, 6, "A");
CW.add("Stew", "Cook by boiling slowly", 1, 5, 4, "B");
CW.add("About", "Approximately", 0, 6, 0, "C");
CW.add("Oil", "Lubricate", 1, 6, 2, "D");
CW.add("Rye", "A grain", 0, 6, 6, "E");
CW.add("Eye", "Stare at", 1, 6, 8, "F");
CW.add("Eel", "Snake-like fish", 0, 8, 0, "G");
CW.add("Waste", "Refuse", 0, 8, 4, "H");
CW.layout();

// framework per rendere automatiche le soluzioni a cruciverba con proprietà/array e metodi
// - spiegare tutti i metodi (di accesso) alle strutture di dati con commenti
// - spiegare il programma in termini di velocità, spazio e le procedure per manipolare i dati

// -- elementi componenti: posizione nella griglia
// - aggiungere attributi/limiti trial words(?) e parti della parola

</script></body></html>
